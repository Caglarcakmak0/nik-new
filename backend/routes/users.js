/**
 * USERS ROUTES - üë§ Kullanƒ±cƒ± Y√∂netimi API
 * 
 * Ama√ß: Kullanƒ±cƒ± kayƒ±t, giri≈ü, profil CRUD i≈ülemleri
 * 
 * Endpoints:
 * - POST /users/register - Yeni kullanƒ±cƒ± kaydƒ± (email, ≈üifre, rol)
 * - POST /users/login - Kullanƒ±cƒ± giri≈üi (JWT token d√∂nd√ºr√ºr)
 * - GET /users/profile - Mevcut kullanƒ±cƒ±nƒ±n profil bilgileri
 * - PUT /users/:id - Kullanƒ±cƒ± profil g√ºncelleme (ki≈üisel, eƒüitim, hedefler)
 * - GET /users/:id - Belirli kullanƒ±cƒ± bilgileri (admin veya kendisi)
 * 
 * Auth: JWT token tabanlƒ± kimlik doƒürulama
 * Data: Profil, eƒüitim bilgileri, target universities, tercihler
 */

const express = require("express");
const router = express.Router();
const bcryptjs = require("bcryptjs");
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const authenticateToken = require('../auth.js');
const { checkRole, checkSameUserOrAdmin } = require('../authRoles.js');
const Users = require("../models/Users.js");
const dotenv = require("dotenv");
const multer = require('multer');
const sharp = require('sharp');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const nodemailer = require('nodemailer');
const { sendTemplatedMail } = require('../services/mailer');

dotenv.config();


const JWT_SECRET_KEY = process.env.JWT_KEY;

// Basit in-memory rate limit (IP ve e‚Äëposta bazlƒ±)
const RATE_LIMIT_IP_MAX = Number(process.env.RATE_LIMIT_FORGOT_IP_MAX || 5);
const RATE_LIMIT_IP_WINDOW_MS = Number(process.env.RATE_LIMIT_FORGOT_IP_WINDOW_MS || 60 * 1000); // 1 dk
const RATE_LIMIT_EMAIL_MAX = Number(process.env.RATE_LIMIT_FORGOT_EMAIL_MAX || 3);
const RATE_LIMIT_EMAIL_WINDOW_MS = Number(process.env.RATE_LIMIT_FORGOT_EMAIL_WINDOW_MS || 60 * 60 * 1000); // 1 saat

const rateStore = {
    ip: new Map(),
    email: new Map()
};

function isLimited(map, key, max, windowMs) {
    const now = Date.now();
    const arr = map.get(key) || [];
    // Eski kayƒ±tlarƒ± temizle
    const recent = arr.filter((ts) => (now - ts) <= windowMs);
    if (recent.length >= max) {
        // Temizlenmi≈ü diziyi geri yaz (hafƒ±zayƒ± sƒ±nƒ±rlƒ± tut)
        map.set(key, recent);
        return true;
    }
    recent.push(now);
    map.set(key, recent);
    return false;
}

// Basit e-posta g√∂nderici (SMTP ile)
const mailTransporter = (() => {
    const host = process.env.SMTP_HOST;
    const port = Number(process.env.SMTP_PORT || 587);
    const user = process.env.SMTP_USER;
    const pass = process.env.SMTP_PASS;
    if (!host || !user || !pass) {
        return null;
    }
    return nodemailer.createTransport({
        host,
        port,
        secure: port === 465,
        auth: { user, pass }
    });
})();

async function sendMail(to, subject, html) {
    if (!mailTransporter) {
        console.warn('SMTP yapƒ±landƒ±rƒ±lmadƒ±, e-posta g√∂nderilmeyecek.');
        return;
    }
    const from = process.env.SMTP_FROM || process.env.SMTP_USER;
    await mailTransporter.sendMail({ from, to, subject, html });
}


// Kullanƒ±cƒ± olu≈üturma - firstName/lastName ile g√ºncellendi
// Admin: Kullanƒ±cƒ± olu≈üturma
router.post("/", authenticateToken, checkRole('admin'), async (req, res) => {
    try {
        const { 
            email, 
            password, 
            firstName, 
            lastName, 
            role = 'student' // Varsayƒ±lan deƒüer
        } = req.body;
        
        // Zorunlu alanlarƒ± kontrol et
        if (!email || !password) {
            return res.status(400).json({ 
                message: "Email ve ≈üifre zorunludur." 
            });
        }
        
        const lowerEmail = email.toLowerCase();
        const hashedPassword = await bcryptjs.hash(password, 10);
        
        // Email kontrol√º
        const existingUser = await Users.findOne({ email: lowerEmail });
        if (existingUser) { 
            return res.status(400).json({ 
                message: "Bu e-posta adresi ba≈üka bir kullanƒ±cƒ± tarafƒ±ndan kullanƒ±lƒ±yor." 
            }); 
        }
        
        // Kullanƒ±cƒ± verisi hazƒ±rla
        const userData = { 
            email: lowerEmail, 
            password: hashedPassword, 
            firstName: firstName || '',
            lastName: lastName || '',
            role 
        };
        
        const newUser = new Users(userData);
        await newUser.save();
        
        // Hassas bilgileri √ßƒ±kararak yanƒ±t ver
        const userWithoutPassword = newUser.toObject();
        delete userWithoutPassword.password;
        delete userWithoutPassword.refreshToken;
        delete userWithoutPassword.refreshTokenVersion;
        delete userWithoutPassword.refreshTokenExpiresAt;
        
        res.status(201).json({ 
            message: "Kullanƒ±cƒ± ba≈üarƒ±yla olu≈üturuldu!",
            data: userWithoutPassword
        });
    } catch (error) {
        console.log(error);
        res.status(500).json({ message: "There is an error: " + error });
    }
});

// Public: Kayƒ±t ol (self-register)
router.post('/register', async (req, res) => {
    try {
        const { email, password, firstName, lastName } = req.body || {};
        if (!email || !password) {
            return res.status(400).json({ message: 'Email ve ≈üifre zorunludur.' });
        }
        const lowerEmail = String(email).toLowerCase();

        const existing = await Users.findOne({ email: lowerEmail });
        if (existing) {
            return res.status(400).json({ message: 'Bu e-posta adresi ba≈üka bir kullanƒ±cƒ± tarafƒ±ndan kullanƒ±lƒ±yor.' });
        }

        const hashedPassword = await bcryptjs.hash(password, 10);

        // E-posta doƒürulamasƒ± i√ßin token √ºret
        const rawToken = crypto.randomBytes(32).toString('hex');
        const tokenHash = crypto.createHash('sha256').update(rawToken).digest('hex');
        const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 saat

        const newUser = await Users.create({
            email: lowerEmail,
            password: hashedPassword,
            firstName: firstName || '',
            lastName: lastName || '',
            role: 'student',
            isEmailVerified: false,
            emailVerificationTokenHash: tokenHash,
            emailVerificationExpiresAt: expiresAt,
        });

        const frontendBase = process.env.FRONTEND_BASE_URL || 'http://localhost:5173';
        const verifyUrl = `${frontendBase}/verify-email?uid=${newUser._id}&token=${rawToken}`;

        // Doƒürulama e-postasƒ± g√∂nder (templated)
        try {
            const logoUrl = process.env.LOGO_PUBLIC_URL || `${process.env.API_PUBLIC_URL || ''}/uploads/logoNik.png`;
            await sendTemplatedMail({
                to: lowerEmail,
                subject: 'E‚Äëposta Doƒürulama',
                template: 'verifyEmail',
                data: {
                    brandName: 'Nik',
                    displayName: `${(firstName || '') + ' ' + (lastName || '')}`.trim() || lowerEmail.split('@')[0],
                    verifyUrl,
                    logoUrl,
                    year: new Date().getFullYear()
                }
            });
        } catch (e) {
            console.warn('Doƒürulama e-postasƒ± g√∂nderilemedi:', e);
        }

        const safeUser = newUser.toObject();
        delete safeUser.password;
        delete safeUser.refreshToken;
        delete safeUser.refreshTokenVersion;
        delete safeUser.refreshTokenExpiresAt;
        delete safeUser.emailVerificationTokenHash;
        delete safeUser.emailVerificationExpiresAt;

        return res.status(201).json({ message: 'Kayƒ±t ba≈üarƒ±lƒ±. L√ºtfen e‚Äëpostanƒ±zƒ± doƒürulayƒ±n.', data: safeUser });
    } catch (error) {
        console.error('POST /users/register error:', error);
        return res.status(500).json({ message: 'Kayƒ±t sƒ±rasƒ±nda bir hata olu≈ütu.' });
    }
});

// Public: E-posta doƒürula
router.post('/verify-email', async (req, res) => {
    try {
        const { uid, token } = req.body || {};
        if (!uid || !token) {
            return res.status(400).json({ message: 'Ge√ßersiz istek.' });
        }
        const user = await Users.findById(uid);
        if (!user || !user.emailVerificationTokenHash || !user.emailVerificationExpiresAt) {
            return res.status(400).json({ message: 'Token ge√ßersiz veya s√ºresi dolmu≈ü.' });
        }
        if (user.emailVerificationExpiresAt.getTime() < Date.now()) {
            await Users.findByIdAndUpdate(uid, {
                emailVerificationTokenHash: null,
                emailVerificationExpiresAt: null
            });
            return res.status(400).json({ message: 'Token s√ºresi dolmu≈ü.' });
        }
        const providedHash = crypto.createHash('sha256').update(token).digest('hex');
        if (providedHash !== user.emailVerificationTokenHash) {
            return res.status(400).json({ message: 'Token ge√ßersiz.' });
        }
        await Users.findByIdAndUpdate(uid, {
            isEmailVerified: true,
            emailVerificationTokenHash: null,
            emailVerificationExpiresAt: null
        });
        return res.status(200).json({ message: 'E‚Äëposta adresiniz doƒürulandƒ±.' });
    } catch (error) {
        console.error('POST /users/verify-email error:', error);
        return res.status(500).json({ message: 'E‚Äëposta doƒürulama sƒ±rasƒ±nda bir hata olu≈ütu.' });
    }
});

// Coach'un √∂ƒürencilerini getir (ger√ßek verilerle)
router.get("/coach/students", authenticateToken, checkRole('coach', 'admin'), async (req, res) => {
    try {
        const coachId = req.user?.userId;
        if (!coachId) {
            return res.status(401).json({ message: 'User ID not found in token' });
        }

        const CoachStudent = require('../models/CoachStudent');
        const DailyPlan = require('../models/DailyPlan');

        // Ko√ßa baƒülƒ± aktif √∂ƒürencileri bul
        const links = await CoachStudent.find({ coachId, status: 'active' }).populate('studentId', 'firstName lastName email avatar grade stats');
        const students = links.map(l => l.studentId);

        // √ñƒürenci yoksa bo≈ü d√∂n
        if (!students || students.length === 0) {
            return res.json({ message: '√ñƒürenci listesi getirildi', data: [] });
        }

        const studentIds = students.map(s => s._id);

        // Son 30 g√ºn i√ßerisindeki plan istatistiklerini topla
        const from = new Date();
        from.setDate(from.getDate() - 30);

        const agg = await DailyPlan.aggregate([
            { $match: { userId: { $in: studentIds }, date: { $gte: from } } },
            {
                $group: {
                    _id: '$userId',
                    activePlansCount: { $sum: { $cond: [{ $in: ['$status', ['active', 'draft']] }, 1, 0] } },
                    avgCompletionRate: { $avg: '$stats.completionRate' },
                    totalStudyTime: { $sum: '$stats.totalStudyTime' }
                }
            }
        ]);

        const metricsByUser = new Map();
        agg.forEach(a => metricsByUser.set(String(a._id), a));

        const enriched = students.map(s => {
            const key = String(s._id);
            const m = metricsByUser.get(key);
            const displayName = (s.firstName && s.lastName) ? `${s.firstName} ${s.lastName}` : (s.firstName || s.lastName || s.email.split('@')[0]);
            return {
                _id: s._id,
                fullName: displayName,
                email: s.email,
                avatar: s.avatar || null,
                grade: s.grade || '12. Sƒ±nƒ±f',
                lastActivity: s.stats?.lastActivity || s.updatedAt || s.createdAt,
                activePlansCount: m?.activePlansCount || 0,
                completionRate: Math.round(m?.avgCompletionRate || 0),
                totalStudyTime: m?.totalStudyTime || 0
            };
        });

        res.json({ message: '√ñƒürenci listesi getirildi', data: enriched });
    } catch (error) {
        console.error('Coach students fetch error:', error);
        res.status(500).json({ message: '√ñƒürenci listesi getirilirken hata olu≈ütu: ' + error });
    }
});


router.post("/login", async (req, res) => {
    try {
        const { password, email } = req.body;
        const lowerEmail = email.toLowerCase();
        const existingUser = await Users.findOne({ email: lowerEmail });
        if (!existingUser) {
            return res.status(400).json({ message: "Kullanƒ±cƒ± bulunamadƒ±!" });
        }
        const isPasswordValid = await bcryptjs.compare(password, existingUser.password);

        if (!isPasswordValid) {
            return res.status(401).json({ message: "Yanlƒ±≈ü ≈üifre!" });
        }

        // Access Token - kƒ±sa s√ºreli (1 saat)
        const token = jwt.sign(
            {
                userId: existingUser._id,
                email: existingUser.email,
                role: existingUser.role,
                tokenVersion: existingUser.tokenVersion
            },
            JWT_SECRET_KEY,
            { expiresIn: '1h' } // Access token 1 saat
        );

        // Refresh Token - uzun s√ºreli (7 g√ºn) 
        const refreshToken = jwt.sign(
            {
                userId: existingUser._id,
                tokenVersion: existingUser.tokenVersion,
                refreshTokenVersion: existingUser.refreshTokenVersion + 1, // Yeni version
                type: 'refresh' // Token tipi belirt
            },
            JWT_SECRET_KEY,
            { expiresIn: '7d' } // Refresh token 7 g√ºn
        );

        // Refresh token'ƒ± database'e kaydet
        const refreshTokenExpiresAt = new Date();
        refreshTokenExpiresAt.setDate(refreshTokenExpiresAt.getDate() + 7); // 7 g√ºn sonra expire

        await Users.findByIdAndUpdate(existingUser._id, {
            refreshToken: refreshToken,
            refreshTokenVersion: existingUser.refreshTokenVersion + 1,
            refreshTokenExpiresAt: refreshTokenExpiresAt
        });

        const userWithoutPassword = existingUser.toObject();
        delete userWithoutPassword.password;
        // Hassas refresh token verilerini response'dan √ßƒ±kar
        delete userWithoutPassword.refreshToken;
        delete userWithoutPassword.refreshTokenVersion;
        delete userWithoutPassword.refreshTokenExpiresAt;

        res.status(200).json({ 
            message: "Giri≈ü ba≈üarƒ±lƒ±!", 
            data: userWithoutPassword, 
            token, // Access token (1 saat)
            refreshToken // Refresh token (7 g√ºn)
        });
    } catch (error) {
        console.log(error);
        res.status(500).json({ message: "There is an error: " + error });
    }
});

// ≈ûifremi Unuttum ‚Äî reset linki g√∂nder
router.post('/forgot-password', async (req, res) => {
    try {
        const { email } = req.body || {};
        if (!email || typeof email !== 'string') {
            return res.status(200).json({ message: 'Eƒüer bu e‚Äëposta kayƒ±tlƒ±ysa, sƒ±fƒ±rlama baƒülantƒ±sƒ± g√∂nderildi.' });
        }

        // Rate limit kontrolleri
        const ip = req.headers['x-forwarded-for']?.toString().split(',')[0].trim() || req.ip || req.connection?.remoteAddress || 'unknown';
        const ipLimited = isLimited(rateStore.ip, ip, RATE_LIMIT_IP_MAX, RATE_LIMIT_IP_WINDOW_MS);
        const emailKey = String(email).toLowerCase();
        const emailLimited = isLimited(rateStore.email, emailKey, RATE_LIMIT_EMAIL_MAX, RATE_LIMIT_EMAIL_WINDOW_MS);
        if (ipLimited || emailLimited) {
            // Uniform response: enumeration korumasƒ±
            return res.status(200).json({ message: 'Eƒüer bu e‚Äëposta kayƒ±tlƒ±ysa, sƒ±fƒ±rlama baƒülantƒ±sƒ± g√∂nderildi.' });
        }

        const lowerEmail = email.toLowerCase();
        const user = await Users.findOne({ email: lowerEmail });

        // Yanƒ±tƒ± uniform tut (enumeration √∂nleme)
        const uniformResponse = () => res.status(200).json({ message: 'Eƒüer bu e‚Äëposta kayƒ±tlƒ±ysa, sƒ±fƒ±rlama baƒülantƒ±sƒ± g√∂nderildi.' });

        if (!user) {
            return uniformResponse();
        }

        // Token √ºret ve hashle
        const rawToken = crypto.randomBytes(32).toString('hex');
        const tokenHash = crypto.createHash('sha256').update(rawToken).digest('hex');
        const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 saat

        await Users.findByIdAndUpdate(user._id, {
            passwordResetTokenHash: tokenHash,
            passwordResetExpiresAt: expiresAt
        });

        const frontendBase = process.env.FRONTEND_BASE_URL || 'http://localhost:5173';
        const resetUrl = `${frontendBase}/reset-password?token=${rawToken}`;
        if (process.env.NODE_ENV !== 'production') {
            console.log('Password reset link:', resetUrl);
        }

        // Templated e-posta g√∂nder
        try {
            const logoUrl = process.env.LOGO_PUBLIC_URL || `${process.env.API_PUBLIC_URL || ''}/uploads/logoNik.png`;
            const asciiSubject = String(process.env.EMAIL_ASCII_SUBJECT || '').toLowerCase() === 'true';
            const subject = asciiSubject ? 'Sifre sifirlama talebiniz' : '≈ûifre Sƒ±fƒ±rlama Talebiniz';
            await sendTemplatedMail({
                to: user.email,
                subject,
                template: 'passwordReset',
                data: {
                    brandName: 'Nik',
                    displayName: `${(user.firstName || '') + ' ' + (user.lastName || '')}`.trim() || user.email.split('@')[0],
                    resetUrl,
                    logoUrl,
                    year: new Date().getFullYear()
                }
            });
        } catch (e) {
            // E-posta g√∂nderilemese bile enumeration korumasƒ± i√ßin success d√∂n
            console.warn('≈ûifre sƒ±fƒ±rlama e-postasƒ± g√∂nderilemedi:', e);
        }
        // Dev ortamƒ±nda debug linki response i√ßine koy (prod'da asla koyma)
        if (process.env.NODE_ENV !== 'production' && String(process.env.EMAIL_DEBUG_LINK || '').toLowerCase() === 'true') {
            return res.status(200).json({ message: 'Eƒüer bu e‚Äëposta kayƒ±tlƒ±ysa, sƒ±fƒ±rlama baƒülantƒ±sƒ± g√∂nderildi.', debugResetUrl: resetUrl });
        }
        return uniformResponse();
    } catch (error) {
        console.error('POST /users/forgot-password error:', error);
        return res.status(500).json({ message: 'ƒ∞≈ülem sƒ±rasƒ±nda bir hata olu≈ütu.' });
    }
});

// ≈ûifre Sƒ±fƒ±rla ‚Äî token doƒürula ve ≈üifreyi g√ºncelle
router.post('/reset-password', async (req, res) => {
    try {
        const { token, newPassword } = req.body || {};
        if (!token || !newPassword) {
            return res.status(400).json({ message: 'Ge√ßersiz istek.' });
        }

        // Token hash'i olu≈ütur ve kullanƒ±cƒ±yƒ± hash ile bul
        const providedHash = crypto.createHash('sha256').update(token).digest('hex');
        const user = await Users.findOne({ passwordResetTokenHash: providedHash });

        if (!user || !user.passwordResetExpiresAt) {
            return res.status(400).json({ message: 'Token ge√ßersiz veya s√ºresi dolmu≈ü.' });
        }

        // S√ºre kontrol√º
        if (user.passwordResetExpiresAt.getTime() < Date.now()) {
            // Token alanlarƒ±nƒ± temizle
            await Users.findByIdAndUpdate(user._id, {
                passwordResetTokenHash: null,
                passwordResetExpiresAt: null
            });
            return res.status(400).json({ message: 'Token s√ºresi dolmu≈ü.' });
        }

        // ≈ûifreyi g√ºncelle
        const hashedPassword = await bcryptjs.hash(newPassword, 10);
        await Users.findByIdAndUpdate(user._id, {
            password: hashedPassword,
            tokenVersion: (user.tokenVersion || 0) + 1, // T√ºm mevcut access token'larƒ± ge√ßersiz kƒ±l
            // Reset token alanlarƒ±nƒ± temizle
            passwordResetTokenHash: null,
            passwordResetExpiresAt: null,
            // Mevcut refresh token'ƒ± da ge√ßersiz kƒ±lmak isterseniz temizleyin
            refreshToken: null,
            refreshTokenExpiresAt: null
        });

        return res.status(200).json({ message: '≈ûifreniz g√ºncellendi. L√ºtfen yeni ≈üifrenizle giri≈ü yapƒ±n.' });
    } catch (error) {
        console.error('POST /users/reset-password error:', error);
        return res.status(500).json({ message: '≈ûifre g√ºncellenirken bir hata olu≈ütu.' });
    }
});

// Kullanƒ±cƒ± g√ºncelleme - Yeni alanlarla desteklendi
router.put("/:id", authenticateToken, checkSameUserOrAdmin, async (req, res) => {
    try {
        const findUser = await Users.findById(req.params.id);
        if (!findUser) {
            return res.status(404).json({ message: "Kullanƒ±cƒ± bulunamadƒ±." });
        }

        let updateData = { ...req.body };
        
        // ≈ûifre g√ºncelleniyorsa hash'le
        if (req.body.password) {
            const hashedPassword = await bcryptjs.hash(req.body.password, 10);
            updateData.password = hashedPassword;
        }
        
        // G√ºvenlik i√ßin token version'ƒ± artƒ±r (≈üifre deƒüi≈ütiƒüinde)
        if (req.body.password) {
            updateData.tokenVersion = findUser.tokenVersion + 1;
        }
        
        // Hassas alanlarƒ± g√ºncellemeden √ßƒ±kar
        delete updateData.refreshToken;
        delete updateData.refreshTokenVersion;
        delete updateData.refreshTokenExpiresAt;
        
        // Kullanƒ±cƒ±yƒ± g√ºncelle ve yeni halini d√∂nd√ºr
        const updatedUser = await Users.findByIdAndUpdate(
            req.params.id, 
            updateData, 
            { new: true, runValidators: true }
        ).select('-password -refreshToken -refreshTokenVersion -refreshTokenExpiresAt');
        
        res.status(200).json({ 
            message: "Kullanƒ±cƒ± ba≈üarƒ±yla g√ºncellendi!", 
            data: updatedUser 
        });
    } catch (error) {
        console.log(error);
        
        // Validation hatalarƒ±nƒ± kullanƒ±cƒ± dostu hale getir
        if (error.name === 'ValidationError') {
            const errorMessages = Object.values(error.errors).map(err => err.message);
            return res.status(400).json({ 
                message: "Validation hatasƒ±", 
                errors: errorMessages 
            });
        }
        
        res.status(500).json({ message: "G√ºncelleme hatasƒ±: " + error });
    }
});

// Login olan kullanƒ±cƒ±nƒ±n kendi profili - Tam bilgiler
router.get("/profile", authenticateToken, async (req, res) => {
    try {
        const userData = await Users.findById(req.user.userId)
            .select('-password -refreshToken -refreshTokenVersion -refreshTokenExpiresAt');
            
        if (!userData) {
            return res.status(404).json({ message: "Kullanƒ±cƒ± bulunamadƒ±" });
        }

        // Profile completeness hesapla (0-100)
        const calculateProfileCompleteness = (user) => {
            const requiredFields = ['firstName', 'lastName', 'phone'];
            const optionalFields = ['currentSchool', 'grade', 'city', 'targetFieldType'];
            
            let completed = 0;
            let total = requiredFields.length + optionalFields.length;
            
            // Zorunlu alanlarƒ± kontrol et (daha y√ºksek aƒüƒ±rlƒ±k)
            requiredFields.forEach(field => {
                if (user[field] && user[field].trim() !== '') completed += 1.5;
            });
            
            // ƒ∞steƒüe baƒülƒ± alanlarƒ± kontrol et
            optionalFields.forEach(field => {
                if (user[field] && user[field] !== '') completed += 1;
            });
            
            return Math.min(Math.round((completed / (total * 1.25)) * 100), 100);
        };

        const profileCompleteness = calculateProfileCompleteness(userData);
        
        // Profile completeness'i database'de g√ºncelle
        if (userData.profileCompleteness !== profileCompleteness) {
            await Users.findByIdAndUpdate(req.user.userId, { 
                profileCompleteness 
            });
        }

        res.status(200).json({ 
            message: "Profil bilgileri ba≈üarƒ±yla getirildi", 
            data: {
                ...userData.toObject(),
                profileCompleteness
            }
        });
    } catch (error) {
        console.log(error);
        res.status(500).json({ message: "Profil getirme hatasƒ±: " + error });
    }
});

// ==== Preferences (In-app notifications) ====
// GET /users/preferences
router.get('/preferences', authenticateToken, async (req, res) => {
    try {
        const user = await Users.findById(req.user.userId).select('preferences');
        if (!user) return res.status(404).json({ message: 'Kullanƒ±cƒ± bulunamadƒ±' });
        return res.json({ message: 'Tercihler', data: user.preferences || {} });
    } catch (error) {
        console.error('GET /users/preferences error:', error);
        return res.status(500).json({ message: error.message });
    }
});

// PUT /users/preferences
router.put('/preferences', authenticateToken, async (req, res) => {
    try {
        const updates = req.body?.preferences || req.body || {};
        const user = await Users.findByIdAndUpdate(
            req.user.userId,
            { $set: Object.fromEntries(Object.entries(updates).map(([k, v]) => ([`preferences.${k}`, v]))) },
            { new: true }
        ).select('preferences');
        if (!user) return res.status(404).json({ message: 'Kullanƒ±cƒ± bulunamadƒ±' });
        return res.json({ message: 'Tercihler g√ºncellendi', data: user.preferences || {} });
    } catch (error) {
        console.error('PUT /users/preferences error:', error);
        return res.status(500).json({ message: error.message });
    }
});

// Kullanƒ±cƒ± tutorial durumunu i≈üaretle
router.post('/tutorial/seen', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.userId;
        const user = await Users.findByIdAndUpdate(
            userId,
            { hasSeenTutorial: true },
            { new: true }
        ).select('-password -refreshToken -refreshTokenVersion -refreshTokenExpiresAt');

        if (!user) {
            return res.status(404).json({ message: 'Kullanƒ±cƒ± bulunamadƒ±' });
        }

        res.json({ message: 'Tutorial durumu g√ºncellendi', data: user });
    } catch (error) {
        console.error('POST /users/tutorial/seen error:', error);
        res.status(500).json({ message: 'Tutorial durumu g√ºncellenemedi: ' + error });
    }
});

router.get("/", authenticateToken, checkRole('admin'), async (req, res) => {
    try {
        const userList = await Users.find().sort({ firstName: 1, lastName: 1 });
        const filteredList = userList.map((u) => {
            const displayName = `${u.firstName || ''} ${u.lastName || ''}`.trim() || u.email;
            return {
                _id: u._id,
                name: displayName,
                mail: u.email,
                role: u.role === "admin" ? "Admin" : 
                      (u.role === "coach" ? "Ko√ß" : 
                       (u.role === "student" ? "√ñƒürenci" : u.role))
            }
        })
        res.status(200).json({ message: "Verilere ba≈üarƒ±yla ula≈üƒ±ldƒ±!", data: filteredList });
    } catch (error) {
        console.log(error);
        res.status(500).json({ message: "There is an error: " + error });
    }
})

router.get("/:id", authenticateToken, checkSameUserOrAdmin, async (req, res) => {
    try {
        const userData = await Users.findById(req.params.id).select('-password -refreshToken -refreshTokenVersion -refreshTokenExpiresAt');
        
        if (!userData) {
            return res.status(404).json({ message: "Kullanƒ±cƒ± bulunamadƒ±" });
        }
        
        // ƒ∞sim birle≈ütirme - firstName + lastName
        const displayName = `${userData.firstName || ''} ${userData.lastName || ''}`.trim() || userData.email;
        const filteredData = {
            _id: userData._id,
            name: displayName,
            firstName: userData.firstName,
            lastName: userData.lastName,
            mail: userData.email,
            role: userData.role,
            phone: userData.phone,
            bio: userData.bio,
            currentSchool: userData.currentSchool,
            grade: userData.grade,
            city: userData.city
        }
        res.status(200).json({ message: "Verilere ba≈üarƒ±yla ula≈üƒ±ldƒ±!", data: filteredData });
    } catch (error) {
        console.log(error);
        res.status(500).json({ message: "There is an error: " + error });
    }
})

router.delete("/:id", authenticateToken, checkRole('admin'), async (req, res) => {
    try {
        const deletedUser = await Users.findByIdAndDelete(req.params.id);
        res.status(200).json({ message: "Kullanƒ±cƒ± ba≈üarƒ±yla silindi!", data: deletedUser });
    } catch (error) {
        console.log(error);
        res.status(500).json({ message: "There is an error: " + error });
    }
})

// Refresh Token Endpoint - Access token'ƒ± yenileme
router.post("/refresh", async (req, res) => {
    try {
        const { refreshToken } = req.body;
        
        if (!refreshToken) {
            return res.status(401).json({ message: "Refresh token gerekli" });
        }

        // Refresh token'ƒ± doƒürula
        let decoded;
        try {
            decoded = jwt.verify(refreshToken, JWT_SECRET_KEY);
        } catch (error) {
            return res.status(401).json({ message: "Ge√ßersiz refresh token" });
        }

        // Token tipini kontrol et
        if (decoded.type !== 'refresh') {
            return res.status(401).json({ message: "Ge√ßersiz token tipi" });
        }

        // Kullanƒ±cƒ±yƒ± database'den al
        const user = await Users.findById(decoded.userId);
        if (!user) {
            return res.status(401).json({ message: "Kullanƒ±cƒ± bulunamadƒ±" });
        }

        // Refresh token kontrol√º - database'deki ile e≈üle≈üiyor mu?
        if (user.refreshToken !== refreshToken) {
            return res.status(401).json({ message: "Refresh token ge√ßersiz" });
        }

        // Refresh token expire kontrol√º
        if (!user.refreshTokenExpiresAt || user.refreshTokenExpiresAt < new Date()) {
            return res.status(401).json({ message: "Refresh token s√ºresi dolmu≈ü" });
        }

        // Version kontrol√º - g√ºvenlik i√ßin
        if (user.refreshTokenVersion !== decoded.refreshTokenVersion) {
            return res.status(401).json({ message: "Refresh token s√ºr√ºm√º eski" });
        }

        // Yeni Access Token olu≈ütur
        const newAccessToken = jwt.sign(
            {
                userId: user._id,
                email: user.email,
                role: user.role,
                tokenVersion: user.tokenVersion
            },
            JWT_SECRET_KEY,
            { expiresIn: '1h' } // Yeni access token 1 saat
        );

        // ƒ∞steƒüe baƒülƒ±: Yeni refresh token da olu≈ütur (rotation)
        const newRefreshToken = jwt.sign(
            {
                userId: user._id,
                tokenVersion: user.tokenVersion,
                refreshTokenVersion: user.refreshTokenVersion + 1,
                type: 'refresh'
            },
            JWT_SECRET_KEY,
            { expiresIn: '7d' }
        );

        // Yeni refresh token'ƒ± database'e kaydet
        const newRefreshTokenExpiresAt = new Date();
        newRefreshTokenExpiresAt.setDate(newRefreshTokenExpiresAt.getDate() + 7);

        await Users.findByIdAndUpdate(user._id, {
            refreshToken: newRefreshToken,
            refreshTokenVersion: user.refreshTokenVersion + 1,
            refreshTokenExpiresAt: newRefreshTokenExpiresAt
        });

        res.status(200).json({
            message: "Token ba≈üarƒ±yla yenilendi",
            token: newAccessToken, // Yeni access token
            refreshToken: newRefreshToken // Yeni refresh token
        });

    } catch (error) {
        console.log("Refresh token error:", error);
        res.status(500).json({ message: "Token yenileme hatasƒ±: " + error });
    }
});

// ====================
// Avatar Upload (self)
// ====================
const avatarUpload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 1 * 1024 * 1024 }, // 1MB
    fileFilter: (req, file, cb) => {
        if (!file.mimetype.startsWith('image/')) {
            return cb(new Error('Sadece resim dosyalarƒ± kabul edilir'));
        }
        cb(null, true);
    }
});

router.post('/avatar', authenticateToken, avatarUpload.single('avatar'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ message: 'Dosya y√ºklenmedi' });
        }

        const userId = req.user.userId;
        const user = await Users.findById(userId);
        if (!user) return res.status(404).json({ message: 'Kullanƒ±cƒ± bulunamadƒ±' });

        // Hedef klas√∂r
        const avatarsDir = path.join(__dirname, '..', 'uploads', 'avatars');
        if (!fs.existsSync(avatarsDir)) {
            fs.mkdirSync(avatarsDir, { recursive: true });
        }

        // Dosya adƒ±
        const filename = `avatar_${userId}_${Date.now()}.webp`;
        const filePath = path.join(avatarsDir, filename);

        // G√∂rseli optimize et ve kaydet
        await sharp(req.file.buffer)
            .resize(256, 256, { fit: 'cover' })
            .webp({ quality: 80 })
            .toFile(filePath);

        // Eski avatarƒ± sil (sadece avatars klas√∂r√ºnde ise)
        if (user.avatar && typeof user.avatar === 'string' && user.avatar.startsWith('/uploads/avatars/')) {
            try {
                const oldAbsPath = path.join(__dirname, '..', user.avatar.replace(/^\//, ''));
                if (fs.existsSync(oldAbsPath)) fs.unlinkSync(oldAbsPath);
            } catch (e) {
                // sessizce ge√ß
            }
        }

        // Kullanƒ±cƒ±yƒ± g√ºncelle
        const publicUrl = `/uploads/avatars/${filename}`;
        user.avatar = publicUrl;
        await user.save();

        return res.json({ message: 'Avatar g√ºncellendi', avatar: publicUrl });
    } catch (error) {
        console.error('POST /users/avatar error:', error);
        return res.status(500).json({ message: error.message });
    }
});

// Get current user's stats (Leaderboard skorlarƒ±na g√∂re)
router.get("/me/stats", authenticateToken, async (req, res) => {
    try {
        const userId = req.user?.userId;
        
        if (!userId) {
            return res.status(401).json({ message: 'User ID not found in token' });
        }
        
        const UserStats = require('../models/UserStats');
        const Achievement = require('../models/Achievement');
        const StudySession = require('../models/StudySession');
        const PracticeExam = require('../models/PracticeExam');

        // Kullanƒ±cƒ±nƒ±n stats'ƒ±nƒ± getir
        let userStats = await UserStats.findOne({ userId }).populate('userId', 'firstName lastName email avatar');
        
        if (!userStats) {
            // Yoksa default stats olu≈ütur
            userStats = await UserStats.create({
                userId,
                totalXP: 0,
                currentLevel: 1,
                nextLevelXP: 1000,
                currentLevelXP: 0,
                streak: 0,
                maxStreak: 0,
                totalAchievements: 0,
                weeklyXP: 0,
                monthlyXP: 0,
                dailyChallenges: []
            });
            
            userStats = await UserStats.findById(userStats._id).populate('userId', 'firstName lastName email avatar');
        }

        // Overall agregasyon: t√ºm zamanlar
        const sessionsAgg = await StudySession.aggregate([
            { $group: { 
                _id: '$userId', 
                totalStudyTime: { $sum: '$duration' },
                totalQuestions: { 
                    $sum: { 
                        $add: [
                            { $ifNull: [ '$questionStats.correctAnswers', 0 ] },
                            { $ifNull: [ '$questionStats.wrongAnswers', 0 ] },
                            { $ifNull: [ '$questionStats.blankAnswers', 0 ] }
                        ]
                    }
                }
            } }
        ]);

        const examsAgg = await PracticeExam.aggregate([
            { $group: { _id: '$userId', totalExamNet: { $sum: '$totals.net' } } }
        ]);

        const userMap = new Map();
        sessionsAgg.forEach(s => {
            userMap.set(String(s._id), { userId: String(s._id), totalStudyTime: s.totalStudyTime || 0, totalQuestions: s.totalQuestions || 0, totalExamNet: 0 });
        });
        examsAgg.forEach(e => {
            const key = String(e._id);
            const cur = userMap.get(key) || { userId: key, totalStudyTime: 0, totalQuestions: 0, totalExamNet: 0 };
            cur.totalExamNet = (cur.totalExamNet || 0) + (e.totalExamNet || 0);
            userMap.set(key, cur);
        });

        // Entry list ve sƒ±ralama
        const entries = Array.from(userMap.values()).map(v => ({
            ...v,
            _primaryScore: v.totalStudyTime || 0,
            _secondaryScore: (v.totalQuestions || 0) + Math.round(v.totalExamNet || 0),
            periodScore: (v.totalStudyTime || 0) + ((v.totalQuestions || 0) + Math.round(v.totalExamNet || 0))
        }));

        entries.sort((a, b) => {
            if (b._primaryScore !== a._primaryScore) return b._primaryScore - a._primaryScore;
            return b._secondaryScore - a._secondaryScore;
        });

        const userIdStr = String(userId);
        const selfIndex = entries.findIndex(e => e.userId === userIdStr);
        const selfAgg = selfIndex >= 0 ? entries[selfIndex] : { totalStudyTime: 0, totalQuestions: 0, totalExamNet: 0, periodScore: 0 };

        // Achievements
        const achievements = await Achievement.find({ userId, unlockedAt: { $ne: null } });
        const formattedAchievements = achievements.map(ach => ({
            id: ach._id.toString(),
            title: ach.title,
            description: ach.description,
            icon: ach.icon,
            rarity: ach.rarity,
            unlockedAt: ach.unlockedAt,
            points: ach.points
        }));

        const result = {
            _id: userStats.userId._id.toString(),
            name: `${userStats.userId.firstName || ''} ${userStats.userId.lastName || ''}`.trim() || 'Kullanƒ±cƒ±',
            totalScore: selfAgg.periodScore || 0,
            totalQuestions: selfAgg.totalQuestions || 0,
            totalStudyTime: selfAgg.totalStudyTime || 0,
            streak: userStats.streak || 0,
            level: userStats.currentLevel || 1,
            experience: userStats.totalXP || 0,
            achievements: formattedAchievements,
            weeklyScore: 0,
            monthlyScore: 0,
            rank: selfIndex >= 0 ? (selfIndex + 1) : entries.length + 1,
            weeklyRank: selfIndex >= 0 ? (selfIndex + 1) : entries.length + 1,
            monthlyRank: selfIndex >= 0 ? (selfIndex + 1) : entries.length + 1
        };

        res.status(200).json({
            message: "Kullanƒ±cƒ± istatistikleri ba≈üarƒ±yla getirildi",
            data: result
        });
        
    } catch (error) {
        console.error('GET /users/me/stats error:', error);
        res.status(500).json({ message: error.message });
    }
});

module.exports = router;